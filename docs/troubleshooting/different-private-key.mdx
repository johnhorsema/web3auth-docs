---
title: Different Private Keys across Integrations
image: "images/docs-meta-cards/documentation-card.png"
displayed_sidebar: docs
description: "Different Private Keys across Integrations | Documentation - Web3Auth"
---

Users frequently face confusion when they get different wallet addresses due to multitudes of reasons. Here's our attempt to explain the possible
reasons for different wallet addresses and what to keep in mind while designing your solutions.

## Factors affecting wallet addresses

### Verifier

A verifier is a piece of information about the OAuth provider being used by the application, which is queried by web3auth auth network nodes from a
smart contract deployed on the Ethereum blockchain to verify the JWT token. To know more about creating verifiers, please refer
[here](/auth-provider-setup/verifiers).

If you use the same verifier across every SDK your wallet address will not change, since all SDKs support all verifiers. When you use different login
providers, verifiers do change even though id, sub, email etc fields remain the same. For such cases, you can use an aggregate verifier.

#### Aggregate Verifier

Aggregate verifier is combining multiple login methods to create a verifier to get the same wallet address for your user for the same email id
regardless of their login providers, for example, combining a Google and Email Passwordless login or Google and GitHub via Auth0 to access the same
key for your user. Refer to the docs [here](/auth-provider-setup/verifiers/aggregate-verifier) to know more about creating an aggregate verifier.

Here, multiple sub-verifiers are combined under one single aggregate verifier, and one wallet address is generated from the aggregate verifier. So for
the case discussed above verifiers with different login providers can be added as sub-verifiers under one aggregate verifier, which would allow users
to get a single wallet address provided one of the field(like email) stays same across sub-verfiers.

### Client ID

To get your Client ID, it's as simple as setting up a new Plug and Play project on the Web3Auth dashboard. Now, "Plug and Play" might sound technical,
but it's just a way of describing the pre-packaged user interface and experience that Web3Auth has ready for you. The idea here is to make integrating
Web3Auth into your project as easy and efficient as possible, saving you the hassle of building everything from scratch. To get a client id for your
project, please refer [here](/auth-provider-setup/client-id).

Wallet addresses changes if client ID changes. Please use the same cleint ID across all your SDK integrations to get the same wallet address.

### Environment

While creating a verifier you need to select between `testnet`, `mainnet`, `aqua`, `cyan`, `sapphire_devnet`, and `sapphire_mainnet`.

`testnet` and `sapphire_devnet` is a sandbox environment for developers to experiment. People usually test and finish their integration here. `mainnet`, `aqua` , & `cyan`
are the production environments for scalable applications.

Every network has different nodes and that causes the keys to change. If you move from one network to another, the keys are meant to change.

### Product

#### PnP And Core-kit

PnP and Core-Kit SDKs have different keys, because we take subkey from the mainkey in PnP SDKs. Please check the `@toruslabs/openlogin-subkey` package
for more details.

In PnP SDKs, there is a parameter `useCoreKitKey` accepting boolean value which can be set to `true` to use the same wallet address as Core-Kit SDKs.
Please check the following code snippet where `useCoreKitKey` is set to `true` while initializing the web-no-modal SDK:

```js
const web3auth = new Web3AuthNoModal({
  clientId,
  chainConfig,
  web3AuthNetwork: "cyan",
  useCoreKitKey: true,
});
```

In core-kit SDKs, there is a parameter `usePnPKey` accepting boolean value which can be set to `true` to use the same wallet address as PnP SDKs.
Please check the following code snippet where `usePnPKey` is set to `true` while initializing the web3auth-sfa SDK:

```js
const web3authSfa = new Web3AuthSFA({
  clientId,
  web3AuthNetwork: "cyan",
  usePnPKey: true,
});
```

#### tKey and PnP

If you're migrating to the tKey JS SDK, it is more manual process in total. Firstly, you need to use the same authentication and verifier details as
the plug and play integration, but additionally, you need to create a subkey of the final private key generated by the Plug and Play SDKs. To do this,
you'll need to use the `@toruslabs/openlogin-subkey` and generate a subkey of the private key with your Plug and Play Client ID as the parameter.

```js
import { subkey } from "@toruslabs/openlogin-subkey";

subkey(PRIVATE_KEY.padStart(64, "0"), Buffer.from(CLIENT_ID, "base64"));
```

#### Torus Wallet

Torus Wallet will always have a different private key since it a wallet built on top of web3auth. It is a separate product and has a different private
key.
